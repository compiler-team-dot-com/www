* The Impcore language in OCaml
Here.

Some OCaml,

#+begin_src ocaml
let x = 42 in x
#+end_src

** Metavariables

x, =x= $x_1$, \(x_1\).

\begin{array}{cc}
  a & b \\
  c & c
\end{array}

| $e$ | Any expression                                           |
| $d$ | Any definition                                           |
| $n$ | Any numeral                                              |
| $x$ | Any name that is meant to refer to variable or parameter |
| $f$ | Any name that is meant to refer to a function            |

** Environments

- Environment $\xi$ holds values for global variables.
- Environment $\phi$ holds definitions of functions.
- Environment $\rho$ holds values of a function's parameters.

Environments $\xi$ and $\phi$ are global and shared, but there is a distinct $\rho$ for every function call. Together, their contents comprise Impcore's /basis/.

*** Operating on environments

Using function notation:

- An empty environment, which does not bind any names, is written $\{\}$.
- Whatever is associated with name $x$ in the environment $\rho$ is written $\rho(x)$.
- The set of names bound in environment $\rho$ is written $\text{dom } \rho$.
- An *extended environment* $\rho$, plus a binding of the name $x$ to $v$, is written $\rho \{ x \mapsto v\}$.
- In an extended environment, the new binding hides previous bindings of $x$:

\begin{array}
$\rho\{ x \mapsto v \}(y) =
  \begin{cases}
  v, & \text{when $x = y$} \\
  \rho(y), & \text{when $x \neq y$}
  \end{cases}
\end{array}

** Operational Semantics
An /abstract machine/ and rules for its execution.

Metavariables of Impcore's operational semantics:

| $e, e_i$              | An expression                                   |
| $d$                   | A definition                                    |
| $x, x_i$              | A name that refers to a variable or a parameter |
| $f$                   | A name that refers to a function                |
| $v, v_i$              | A value                                         |
| $\xi, \xi', \ldots$   | A global-variable environment                   |
| $\phi, \phi', \ldots$ | A function-definition environment               |
| $\rho, \rho', \ldots$ | A formal-parameter environment                  |

The states and transitions are described using the metavariables above.

- Evaluating a definition $d$: $\langle d, \xi, \phi \rangle$ (definitions do not appear inside functions).
- Evaluating an expression $e$: $\langle e, \xi, \phi, \rho \rangle$.
- Between evaluations: $\langle \xi, \phi \rangle$.

Environments $\xi$ and $\rho$ store values. Environment $\phi$ stores primitive functions and user-defined functions:

- A primitive function is written as $\mathrm{PRIMITIVE}(\oplus)$, where $\oplus$ stands for a name like $+$, $=$ or $*$.
- A user-defined function is written as $\mathrm{USER}(\langle x_1, \ldots , x_n \rangle , e)$, where the $x_i$'s are the formal parameters and $e$ is the body.

*** Judgements and rules of inference

State transitions are described using /judgements/. A /judgement/ describes a relation, not a function. A language that permits ambiguity is /nondeterministic/. Impcore is deterministic.

The /form/ of the judgement $\langle e\text{, } \xi \text{, } \phi \text{, } \rho \rangle \Downarrow \langle v \text{, } \xi' \text{, } \phi \text{, } \rho' \rangle$ tells us a few things:

- Evaluating an expression always produces a value, unless the machine gets stuck.
- Evaluating an expression might change the value of a global variable, or a formal parameter.
- Evaluating an expression never adds or changes a function definition.

All the required computation in one big step: /big-step/ semantics.

The judgement for a definition: $\langle d \text{, } \xi \text{, } \phi \rangle \rightarrow \langle \xi' \text{, } \phi' \rangle$.

To say which judgements describe real behaviours, an operational semantics uses /rules of inference/:

\begin{array}{cr}
\begin{prooftree}
\AxiomC{$\textit{premises}$}
\RightLabel{.}
\UnaryInfC{$\textit{conclusion}$}
\end{prooftree} &
\textrm{(Name of Rule)}
\end{array}

Example:

\begin{array}{cr}
\begin{prooftree}
\AxiomC{$\langle e_1, \xi, \phi, \rho \rangle \Downarrow \langle v_1, \xi', \phi, \rho' \rangle$}
\AxiomC{$v_1 \neq 0$}
\AxiomC{$\langle e_2, \xi', \phi, \rho' \rangle \Downarrow \langle v_2, \xi'', \phi, \rho'' \rangle$}
\TrinaryInfC{$\langle \textrm{IF} (e_1, e_2, e_3), \xi, \phi, \rho \rangle \Downarrow \langle v_2, \xi'', \phi, \rho'' \rangle$}
\end{prooftree} &
\textrm{(IfTrue)}
\end{array}

- If $\langle e_1, \xi, \phi, \rho \rangle$ evaluates to some nonzero value $v_1$.
- The expression $\textrm{IF} (e_1, e_2, e_3)$ evaluates to the result of evaluating $e_2$ in the environment produced by $e_1$ (including any side-effects).
- $e_1$ is evaluated before $e_2$: Order of evaluation is determined not by the order in which the premises are written, but by the flow of data (the environments) through the computation.
